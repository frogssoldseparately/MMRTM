/** A class that creates and holds provided add-on instances. */
class AddOnGenerator {
  /**
   * Holds each add-on instance behinds keys of class names.
   * @type {Object}
   */
  #addons = {};
  /**
   * The parser used to generate snippets by all add-on's.
   * @type {DOMParser}
   */
  domParser = new DOMParser();
  /**
   * Get an array of all known add-on instances.
   * @returns {Array<AddOn>} A generated array of held add-on instances.
   */
  get instances() {
    const arr = [];
    this.names.forEach((name) => {
      arr.push(this.#addons[name]);
    });
    return arr;
  }
  /**
   * Get an array of all known add-on class names.
   * @returns {Array<string>} A generated array of held add-on instance class names.
   */
  get names() {
    return Object.getOwnPropertyNames(this.#addons);
  }

  /**
   * Generates one or more instances from provided class handles for use in the modifier.
   * @param  {...Function} handles - One or more class handles for known add-on's.
   */
  know(...handles) {
    handles.forEach((handle) => {
      this.#addons[handle.name] = new handle();
    });
  }

  /**
   * Fetches an instance of the desired class name, as generated by the know() method.
   * @param {string} name - The class name of the instance being fetched.
   * @returns {Object} The instance of the desired class.
   */
  getInstance(name) {
    return this.#addons[name];
  }
}

/**
 * A container and controller for a select element holding add-on entries. This facilitates moving elements back
 * and forth between two select elements.
 */
class SelectionContainer {
  /**
   * Create a SelectionContainer. Adds keydown listeners to the provided select element,
   * and generates SelectionEntry instances for each add-on instance.
   * @param {HTMLSelectElement} selectionElement - The select element that will be controlled.
   * @param {Array<AddOn>} addOnInstances - Add-on instances that will be used to populate the select element.
   */
  constructor(selectionElement, addOnInstances) {
    this.element = selectionElement;
    this.element.addEventListener("keydown", (event) => {
      if (event.key == "Enter") {
        Array.from(this.element.selectedOptions).forEach((elem) => {
          // Get each SelectionEntry instance associated with highlighted option elements.
          const entry = this.getEntry("element", elem);
          // Get the sister SelectionContainer instance to adopt these elements, which
          // will also orphan them from this container.
          this.swapTarget.adopt(entry);
        });
        // This is to prevent the first entry in the select element from being automatically highlighted.
        this.swapTarget.element.selectedIndex = -1;
      } else if (event.key === "<") {
        // move elements up
        // TODO: implement this for convenience sake.
      } else if (event.key === ">") {
        // move elements down
        // TODO: implement this for convenience sake.
      }
    });

    // Generates each SelectionEntry instance required and appends all generated option elements to the select
    // element associated with this container instance.
    addOnInstances.forEach((addOn) => {
      const entry = new SelectionEntry(this, addOn);
      this.element.appendChild(entry.element);
      this.entries.push(entry);
    });
  }

  /**
   * The select element being controlled.
   * @type {HTMLSelectElement}
   */
  element;
  /**
   * The entries currently populating this select element.
   * @type {Array<SelectionEntry>}
   */
  entries = [];
  /**
   * An accompanying SelectionContainer instance to trade entries back and forth with. This is set externally.
   * @type {SelectionContainer}
   */
  swapTarget;
  /**
   * A handler for running additional code after an entry is moved into the associated select element. This is
   * meant to be set externally.
   * @param {SelectionEntry} entry - The entry being moved in.
   */
  whenAdopted = (entry) => {};
  /**
   * A handler for running additional code after an entry is removed from the associated select element. This
   * is meant to be set externally. As this is for additional control over when something can be orphaned/adopted,
   * not setting this will always return true to allow adoption when additional logic is not required.
   * @param {SelectionEntry} entry - The entry being removed.
   * @returns {boolean} Whether or not the entry was removed successfully.
   */
  whenOrphaned = (entry) => true;

  /**
   * Facilitates moving entries into this selection container only if the entry isn't already owned by this
   * container, and it was successfully orphaned by its previous container.
   * @param {SelectionEntry} entry - The entry being moved in.
   */
  adopt(entry) {
    // This is to catch the case of an add-on that once existed, but no longer does. I.E., a userscript add-on
    // that was previously used but is now inaccessible with userscripts disabled.
    if (entry == null) return;
    if (entry.parent !== this && entry.parent.orphan(entry)) {
      entry.parent = this;
      this.element.appendChild(entry.element);
      this.entries.push(entry);
      this.whenAdopted(entry);
    }
  }

  /**
   * Gets all owned entry instance values at a specified property.
   * @param {string} prop - The target property of each owned SelectionEntry instance.
   * @returns {Array} An array of values held by each instance of the desired property.
   */
  getArrayOf(prop) {
    return this.entries.map((entry) => entry[prop]);
  }

  /**
   * Get the first member from entries that has a specified property - value pair.
   * @param {string} prop - The property being checked against.
   * @param {*} value - The value to check with.
   * @returns {SelectionEntry} The first matching instance. Returns undefined if there's no match.
   */
  getEntry(prop, value) {
    return this.entries.find((entry) => entry[prop] === value);
  }

  /**
   * Facilitates removing entries from this selection container only if the entry is owned by this container.
   * @param {SelectionEntry} entry - The entry being removed.
   * @returns {boolean} Whether or not the entry was successfully removed. Returns undefined if the entry wasn't
   * owned by this container.
   */
  orphan(entry) {
    if (entry.parent === this) {
      // This line is probably not needed anymore, but I'm too afraid to remove it.
      entry.parent = null;
      // Remove from both this container instance and the select element so it can be appened to the other
      // container successfully.
      this.entries.splice(this.entries.indexOf(entry), 1);
      this.element.removeChild(entry.element);
      return this.whenOrphaned(entry);
    }
    // This should probably return false, but it works in it's current state.
  }
}

/** A container for an individual entry in a SelectionContainer instance. */
class SelectionEntry {
  /**
   * Creates a SelectionEntry, populates itself with information from an add-on instance, and creates an option
   * element to be placed in a select element.
   * @param {SelectionContainer} parent - The container currently holding this instance.
   * @param {AddOn} instance - The associated add-on instance.
   */
  constructor(parent, instance) {
    this.parent = parent;
    // This information is grabbed so the instance doesn't need to be referenced as much. Preference.
    this.description = instance.description;
    this.key = instance.key;
    this.name = instance.name;
    this.instance = instance;

    // Creates an option element, but does not append this to anything. This is for the SelectionContainer to
    // handle.
    const option = document.createElement("option");
    option.setAttribute("entry-key", this.key);
    option.appendChild(document.createTextNode(this.name));
    option.title = this.description;
    this.element = option;
  }

  /**
   * The description value pulled from the associated add-on instance.
   * @type {string}
   */
  description;
  /**
   * The associated option element generated for this entry.
   * @type {HTMLOptionElement}
   */
  element;
  /**
   * The associated add-on instance.
   * @type {AddOn}
   */
  instance;
  /**
   * The key value pulled from the associated add-on instance.
   * @type {string}
   */
  key;
  /**
   * The name value pulled from the associated add-on instance.
   * @type {string}
   */
  name;
  /**
   * The container currently holding this instance.
   * @type {SelectionContainer}
   */
  parent;
}

/** A container for an injectable snippet, parsed into a workable DOM, as used by add-on's and the modifier. */
class Snippet {
  /**
   * Creates a Snippet from a raw, parseable string. For more information, see DOMParser.parseFromString().
   * @param {string} content - A parseable piece of HTML being passed to a DOMParser instance.
   * @param {string} type - What the content is going to be parsed as.
   */
  constructor(content, type) {
    this.DOM = aog.domParser.parseFromString(content, type);
  }

  /**
   * The captured output of DOMParser.parseFromString(). A workable DOM.
   * @type {Object}
   */
  DOM = { toString: () => "example" };
  /**
   * Get the text representation of the DOM.
   * @returns {string} The inner HTML of the document element.
   */
  get raw() {
    return this.DOM.documentElement.innerHTML;
  }
  /**
   * Get the head element of the contained DOM.
   * @returns {HTMLHeadElement} The DOM's head element.
   */
  get head() {
    return this.DOM.head;
  }
  /**
   * Get the body element of the contained DOM.
   * @returns {HTMLBodyElement} The DOM's body element
   */
  get body() {
    return this.DOM.body;
  }
}

/**
 * A handler for staging during the modifier's build process. This is just a fancy wrapper
 * for an array that is consumed one element at a time at the behest of some outside influence.
 */
class StageManager {
  /**
   * Creates a StageManager with a set series of stages to consume.
   * @param  {...string} stages - The name of each stage that will be handled in order from the 0th
   * element to the Nth element.
   */
  constructor(...stages) {
    this.#stages = stages;
  }

  /**
   * The stages that are being tracked.
   * @type {Array<string>}
   */
  #stages;
  /**
   * Get the stage name at the 0th position of the stages array without consuming anything.
   * @returns {string} The current stage. Returns undefined if there are no more stages.
   */
  get current() {
    if (this.hasNext()) return this.#stages[0];
    return undefined;
  }
  /**
   * Get the stages array's current length.
   * @returns {number} The contained array's current length.
   */
  get length() {
    return this.#stages.length;
  }

  /**
   * Consume the next stage.
   */
  advance() {
    this.#stages.shift();
  }

  /**
   * Whether or not there is at least one more stage held by the stages array.
   * @returns {boolean} Whether or not there are more stages.
   */
  hasNext() {
    return this.length > 0;
  }
}

/** The backbone for creating add-on's with the modifier. All add-on classes extend this. */
class AddOn {
  /**
   * Whether the add-on is open in a popup or not.
   * @type {boolean}
   */
  #openInPopup = !!window.opener && window.opener !== window;
  /**
   * Snippets generated by this add-on stored behind respective snippet names.
   * @type {Object}
   */
  #snippets = {};
  /**
   * Fetches an add-on, if it exists, from the Modifier instance. This allows for add-on's
   * to be able to communicate with each other without having to give them access to the
   * Modifier instance. Due to this desired isolation, this is set externally.
   * @param {string} addOnKey - The key property value of the desired add-on.
   * @returns {AddOn} The desired add-on instance.
   */
  getAddOn = (addOnKey) => {};
  /**
   * Whether or not some alerts and logs are omitted during building.
   * @type {boolean}
   */
  muted = true;
  /**
   * An array of snippets that must be created before the final write stage of the Modifier instance.
   * @type {Array<string>}
   */
  promisedSnippets = [];
  /**
   * The shared StageManager instance to control what is executed when within the AddOn instance.
   * This is set externally to ensure everything is synced up, and is one less thing that can be bugged
   * on an add-on by add-on basis.
   */
  stageManager;
  /**
   * Get all created snippets from this AddOn instance.
   * @returns {Array<string>} Array of snippet path names of the form "[this add-on key]/[snippet name]".
   */
  get snippetPaths() {
    const snippetPaths = [];
    this.promisedSnippets.forEach((snippetName) => {
      snippetPaths.push(this.key + "/" + snippetName);
    });
    return snippetPaths;
  }
  /**
   * Get all snippet names from promisedSnippets that don't yet exist.
   * @returns {Array<string>} Array of snippet names that weren't created.
   */
  get missingSnippets() {
    const missingSnippets = [];
    this.promisedSnippets.forEach((snippetName) => {
      if (this.getSnippet(snippetName) == null)
        missingSnippets.push(snippetName);
    });
    return missingSnippets;
  }
  /**
   * Get whether this add-on is a popup or not.
   * @returns {boolean} Whether or not this is a popup.
   */
  get isPopup() {
    return this.#openInPopup;
  }

  /**
   * Logs information about the passed function handle from an AddOn instance. Used for debugging.
   * @param {Function} handle - What AddOn function is being logged.
   */
  #noImplementation(handle) {
    if (!this.muted) {
      console.log(
        this.constructor.name + " has no implementation for " + handle.name
      );
    }
  }

  /**
   * Sets properties within this AddOn instance using property value pairs.
   * @param  {...any} args - Property value pairs.
   */
  setup(...args) {
    if (args.length % 2 != 0) throw new Error("Expected property value pairs.");
    for (var i = 0; i < args.length; i += 2) {
      const property = args[i];
      const value = args[i + 1];
      this[property] = value;
    }
  }

  /**
   * Sets properties within this AddOn instance using property value pairs. I'm not entirely sure
   * why this is a duplicate of AddOn.setup(), but it stays for now.
   * @param  {...any} args - Property value pairs.
   */
  prep(...args) {
    if (args.length % 2 != 0) throw new Error("Expected property value pairs.");
    for (var i = 0; i < args.length; i += 2) {
      const property = args[i];
      const value = args[i + 1];
      this[property] = value;
    }
  }

  /**
   * Execute a stage function based on stageManager's state. This does not consume any values held by stageManager.
   */
  stage() {
    switch (this.stageManager.current) {
      case "now":
        this.now();
        break;
      case "preBake":
        this.preBake();
        break;
      case "bake":
        this.bake();
        break;
      case "postBake":
        this.postBake();
        break;
      case "preWrite":
        this.preWrite();
        break;
      default:
        // This should never be reached, since stageManager's contents are set in stone.
        throw new Error(
          this.stageManager.current + " is not a valid add-on build stage."
        );
    }
    // Log additional information for debugging purposes.
    if (!this.muted) {
      console.log(
        this.constructor.name +
          " successfully completed stage: " +
          this.stageManager.current
      );
    }
  }

  /**
   * A skeleton to be implemented by an extending class. If unmuted, logs that this method
   * was unimplemented in the extending class.
   */
  now() {
    this.#noImplementation(this.now);
  }

  /**
   * A skeleton to be implemented by an extending class. If unmuted, logs that this method
   * was unimplemented in the extending class.
   */
  preBake() {
    this.#noImplementation(this.preBake);
  }

  /**
   * A skeleton to be implemented by an extending class.
   */
  bake() {}

  /**
   * A skeleton to be implemented by an extending class. If unmuted, logs that this method
   * was unimplemented in the extending class.
   */
  postBake() {
    this.#noImplementation(this.postBake);
  }

  /**
   * A skeleton to be implemented by an extending class. If unmuted, logs that this method
   * was unimplemented in the extending class.
   */
  preWrite() {
    this.#noImplementation(this.preWrite);
  }

  /**
   * Get a created Snippet instance by name.
   * @param {string} snippetName - The desired snippet's name.
   * @returns {Snippet} The desired Snippet instance. Returns undefined if the snippet does
   * not exist.
   */
  getSnippet(snippetName) {
    return this.#snippets[snippetName];
  }

  /**
   * Get a created Snippet instance by path name from another AddOn instance. This comes in the form of
   * "[add-on key]/[snippet name]". This is set by the Modifier instance.
   * @param {string} snippetPath - The desired snippet's path.
   * @returns {Snippet} The desired Snippet instance.
   */
  getExternalSnippet = (snippetPath) => {};

  /**
   * Creates a new Snippet instance from the contents of a provided script element, stores it within the AddOn instance,
   * and returns the same instance.
   * @param {string} name - The name used to access the created Snippet instance.
   * @param {HTMLScriptElement} domElement - The element whose contents are used to create a Snippet instance.
   * @param {string} type - How the domElement's content will be parsed by DOMParser.parseFromString(). The default
   * value of "text/html" should be good for most usecases.
   * @returns {Snippet} The Snippet instance that was created.
   */
  newSnippet(name, domElement, type = "text/html") {
    var injectable = domElement.innerText.trim();
    // Get information about the script element to determine how to process the contents.
    var contentType = domElement.getAttribute("content");
    var location = domElement.getAttribute("location");
    var replacements = domElement.getAttribute("replaces");
    replacements = replacements != null ? replacements.split(";") : [];
    replacements.forEach((elem) => {
      const elemParts = elem.split("=").map((part) => part.trim());
      // These will always come in the form "[target]=[settings property]".
      const target = "${" + elemParts.shift() + "}";
      const value = elemParts.shift();
      // This is done by eval() to allow access to more than just surface level properties.
      const resolvedValue = eval("this.settings." + value + ";");
      injectable = injectable.replaceAll(target, resolvedValue);
    });
    // This allows for omitting wrapping script or style tags, as this does it for properly attributed scripts.
    switch (contentType) {
      case null: // Assumed to be JavaScript.
      case "js":
        const stage = domElement.getAttribute("stage");
        // Wraps the script in an arbitrary event listener.
        if (stage != null) {
          injectable = `window.addEventListener("${stage}", () => {\n${injectable}\n});`;
        }
        injectable = "<script>" + injectable + "</script>";
        // The intended script parent is assumed to be the body element.
        if (location == null) location = "body";
        break;
      case "css":
        injectable = "<style>" + injectable + "</style>";
        // The intended style parent is assumed to be the head element.
        if (location == null) location = "head";
        break;
      case "html":
      default:
      // Do nothing. The element's content should've provided context.
    }
    switch (location) {
      case "head":
        injectable = "<head>" + injectable + "</head>";
        break;
      case "body":
        injectable = "<body>" + injectable + "</body>";
        break;
      case null:
      default:
      // do nothing
    }
    return this.newSnippetFromString(name, injectable, type);
  }

  /**
   * Creates a new Snippet instance from a provided, parseable string, stores it within the AddOn instance, and
   * returns the same instance.
   * @param {string} name - The name used to reference the Snippet instance.
   * @param {string} string - The string that will be processed by DOMParser.
   * @param {string} type - What the string will be parsed as. The default value of "text/html"
   * should work for most usecases.
   * @returns {Snippet} The Snippet instance that was created.
   */
  newSnippetFromString(name, string, type = "text/html") {
    this.#snippets[name] = new Snippet(string, type);
    return this.#snippets[name];
  }

  /**
   * Creates a new Snippet instance from the contents of a provided script element, stores it within the AddOn instance,
   * and returns the same instance if and only if testBoolean is true. If testBoolean is false, will instead show an
   * alert and remove the provided name from the promisedSnippets array.
   * @param {string} name - The name used to reference the Snippet instance.
   * @param {HTMLScriptElement} domElement - The element whose contents are used to create a Snippet instance.
   * @param {string} type - What the string will be parsed as. The default value of "text/html"
   * should work for most usecases.
   * @param {boolean} testBoolean - Whether or not the Snippet instance can be created.
   * @param {string} alertText - The text to show to the user if alerts can be shown.
   * @returns {Snippet} The Snippet instance created. If no Snippet instance was created, returns null.
   */
  newOptionalSnippet(
    name,
    domElement,
    type = "text/html",
    testBoolean = false,
    alertText
  ) {
    if (testBoolean) {
      if (AddOn.showsAlerts) {
        alert(alertText);
      }
      return this.newSnippet(name, domElement, type);
    } else {
      this.promisedSnippets.splice(this.promisedSnippets.indexOf(name), 1);
    }
    return null;
  }

  /**
   * Whether or not to show alerts from failed optional Snippet instance creation. Is true by default.
   * @type {boolean}
   */
  static showsAlerts = true;
}

/**
 * A container add-on for the original, unmodified tracker.
 * @extends AddOn
 */
class Tracker extends AddOn {
  key = "tracker";
  name = "Base Tracker";
  description = "[REQUIRED] The base tracker contents.";
  promisedSnippets = ["content"];
  /**
   * @property {boolean} showLoadingScreen - Shows the loading splash screen while the tracker is modified.
   */
  settings = {
    showLoadingScreen: true,
  };

  /**
   * Converts the provided tracker.html raw text into a workable DOM as "tracker/content".
   */
  bake() {
    const content = this.newSnippetFromString(
      "content",
      rawTracker,
      "text/html"
    );
    // Fixes orphaned text that messes with some stuff.
    this.repairText(
      content.body.querySelector("#highlight-checks"),
      "Highlight available checks"
    );
  }

  /**
   * Creates a span containing some target element and a paragraph and injects it
   * at previousSibling's position.
   * @param {HTMLElement} previousSibling - The element to lump the text with.
   * @param {string} text - The text to create a paragraph element for.
   */
  repairText(previousSibling, text) {
    const nextSibling = previousSibling.nextSibling;
    const restoredText = document.createElement("p");
    restoredText.appendChild(document.createTextNode(text));
    const holdingSpan = document.createElement("span");
    holdingSpan.style.display = "flex";
    holdingSpan.appendChild(previousSibling);
    holdingSpan.appendChild(restoredText);
    nextSibling.parentNode.insertBefore(holdingSpan, nextSibling);
  }
}

/**
 * Creates a map to help with navigating the modified tracker.
 * @extends AddOn
 */
class MapNavigator extends AddOn {
  key = "mapNavigator";
  name = "Map Navigator";
  description =
    "Adds a static map to more easily navigate the tracker by location.";
  promisedSnippets = [
    "style",
    "globals",
    "map",
    "controller",
    "checkAssignment",
    "shortcuts",
  ];
  /**
   * Adds the "sharedModifier/communicator" snippet to the planned snippets to inject.
   */
  preBake() {
    this.getAddOn("sharedModifier").include("communicator");
  }

  /**
   * Creates all snippets for the non-popup mode of this add-on.
   */
  bake() {
    if (this.isPopup) {
      this.bakePopup();
    } else {
      if (
        this.settings.enablePopupMode != null &&
        this.settings.enablePopupMode.toString().toLowerCase() === "true"
      ) {
        // Include only the snippets needed for the original window. Not the pop-up.
        this.promisedSnippets = [
          "communicator",
          "checkAssignment",
          "shortcuts",
        ];
        this.newSnippet(
          "communicator",
          document.getElementById("mapNavigator-communicator"),
          "text/html"
        );
        this.newOptionalSnippet(
          "shortcuts",
          document.getElementById("mapNavigator-popup-shortcuts"),
          "text/html",
          this.settings.enableShortcuts != null &&
            this.settings.enableShortcuts.toLowerCase() === "true",
          "Having shortcuts enabled on MapNavigator adds the following:\n" +
            "[SHIFT + m]\t=> Reopen closed map\n"
        );
      } else {
        // Create the non-popup snippets.
        this.newSnippet(
          "style",
          document.getElementById("mapNavigator-style"),
          "text/html"
        );
        this.newSnippet(
          "globals",
          document.getElementById("mapNavigator-globals"),
          "text/html"
        );
        this.newSnippet(
          "controller",
          document.getElementById("mapNavigator-mapController"),
          "text/html"
        );
        this.newSnippet(
          "map",
          document.getElementById("mapNavigator-map"),
          "text/html"
        );
        this.newOptionalSnippet(
          "shortcuts",
          document.getElementById("mapNavigator-shortcuts"),
          "text/html",
          this.settings.enableShortcuts != null &&
            this.settings.enableShortcuts.toLowerCase() === "true",
          "Having shortcuts enabled on MapNavigator adds the following:\n" +
            "[SHIFT + m]\t=> Toggle map visibility\n" +
            "[,]\t\t\t=> Decrease map size by 50\n" +
            "[SHIFT + <]\t=> Set map size to minimum\n" +
            "[.]\t\t\t=> Increase map size by 50\n" +
            "[SHIFT + >]\t=> Set map size to maximum\n"
        );
      }
      // mapNavigator/checkAssignment is needed whether popup mode is active or not.
      const checkAssignmentJS = this.generateCheckJS();
      this.newSnippetFromString(
        "checkAssignment",
        "<body><script>" + checkAssignmentJS + "</script></body>",
        "text/html"
      );
    }
  }

  /**
   * Creates all snippets for popup mode of this add-on.
   */
  bakePopup() {
    this.promisedSnippets = ["style", "globals", "map"];
    this.newSnippet(
      "style",
      document.getElementById("mapNavigator-popup-style"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("mapNavigator-popup-globals"),
      "text/html"
    );
    this.newSnippet(
      "map",
      document.getElementById("mapNavigator-map"),
      "text/html"
    );
  }

  /**
   * Creates and appends navigation and region buttons to the map.
   */
  postBake() {
    if (
      this.settings.enablePopupMode != null &&
      this.settings.enablePopupMode.toString().toLowerCase() === "true" &&
      !this.isPopup
    )
      return;

    const originalDOM = this.getExternalSnippet("tracker/content").DOM;

    if (
      this.settings.revertStyleInActorizer != null &&
      this.settings.revertStyleInActorizer.toString().toLowerCase() === "true"
    ) {
      // If you are playing through Isghj's Actorizer, this reverts button styling.
      const firstStyleTag = originalDOM.querySelector("style");
      const buttonStylingIndex =
        firstStyleTag.innerText.search(/\W\Wbutton {([^}]*)}/);
      if (buttonStylingIndex !== -1) {
        // Button styling in the style tag was found. Now, remove it.
        const firstStyleContent = firstStyleTag.innerText;
        const buttonStylingCapIndex =
          firstStyleContent.indexOf("}", buttonStylingIndex) + 3;
        firstStyleTag.innerText = "";
        firstStyleTag.appendChild(
          document.createTextNode(
            firstStyleContent.slice(0, buttonStylingIndex) +
              firstStyleContent.slice(buttonStylingCapIndex)
          )
        );
      }
    }

    // The row elements denoting region in the Item Replacements table.
    const regionRows = Array.from(
      originalDOM.querySelectorAll("tr.region > td[colspan='3']")
    );
    const mapDOM = this.getSnippet("map").DOM;
    const mapContainer = mapDOM.querySelector("#map-container");

    const regionData = this.settings.regionOwnership;
    const regionNames = Object.getOwnPropertyNames(regionData);

    // Create each region button for the map.
    regionNames.forEach((regionName) => {
      // Grab display information about the button from user settings.
      const bnStyle = regionData[regionName].style;
      const bnLabel = regionData[regionName].label;
      const bnTitle = regionData[regionName].title
        ? regionData[regionName].title
        : regionName;

      const regionButton = document.createElement("button");
      regionButton.id = SharedModifier.generateButtonId(regionName);
      regionButton.style = bnStyle;
      regionButton.className = "floating-map-button";
      // Used to check specific rows when settings.hideClearedLocations is set to true.
      regionButton.setAttribute(
        "data-regionclass",
        SharedModifier.generateRegionClass(regionName)
      );
      // When finding the region row to scroll to on button click, it will check each
      // provided region, starting with the parent region, until one that exists is found.
      // This is done so that you can have one settings setup that works for every combination
      // of randomizer settings. Depending on the randomizer settings, a region may not exist
      // on the tracker.
      var attemptedRegion = regionName;
      var attemptedRegionSuccess = false;
      for (var i = 0; i < regionData[regionName].locations.length + 1; i++) {
        if (regionRows.find((row) => row.innerText === attemptedRegion)) {
          attemptedRegionSuccess = true;
          break;
        } else {
          attemptedRegion = regionData[regionName].locations[i];
        }
      }
      // Default to scrolling to the top of the Item Replacements table if no valid region was found.
      // Again, this is for flexibility of the settings.
      if (!attemptedRegionSuccess) attemptedRegion = "Misc";
      // Scroll to found region using its id, as set by SharedModifier.prepItemReplacementsTable().
      regionButton.setAttribute(
        "onclick",
        `goToId("#${SharedModifier.generateRowId(attemptedRegion)}")`
      );
      // Shows other regions associated with this button on right-click. This is done with a string corresponding with
      // an array of region names because this is messy, and I'll fix it up later.
      regionButton.setAttribute(
        "oncontextmenu",
        `showSubregionButtons(event, "[\\"${regionData[regionName].locations
          .map((elem) => SharedModifier.generateRowId(elem))
          .join('\\",\\"')}\\"]")`
      );
      regionButton.title = bnTitle;
      regionButton.innerHTML = bnLabel;
      mapContainer.appendChild(regionButton);
    });
    const navButtons = this.settings.navButtons;
    // Create the navigation buttons atop the map container.
    const navButtonElements = navButtons.map((navButton) => {
      const btn = document.createElement("button");
      if (navButton.innerHTML) {
        btn.appendChild(document.createTextNode(navButton.innerHTML));
        delete navButton.innerHTML;
      }
      // While only one of the following properties should be used at a time, I'm checking for each individually to minimize
      // unexpected behavior.
      if (navButton.className) {
        var splitStr = navButton.className.split(" ");
        splitStr.forEach((className) => {
          btn.classList.add(className);
        });
        delete navButton.className;
      }
      if (navButton.classList) {
        var splitStr = navButton.classList.split(" ");
        splitStr.forEach((className) => {
          btn.classList.add(className);
        });
        delete navButton.classList;
      }
      if (navButton["class"]) {
        var splitStr = navButton["class"].split(" ");
        splitStr.forEach((className) => {
          btn.classList.add(className);
        });
        delete navButton["class"];
      }

      // Arbitrary property value pairs are allowed. This may not always be the case, but I wanted to leave it open
      // for further customization for now.
      const props = Object.getOwnPropertyNames(navButton);
      props.forEach((prop) => {
        btn.setAttribute(prop, navButton[prop]);
      });
      return btn;
    });
    const navContainer = mapDOM.querySelector("#navigation-container");
    navContainer.prepend(...navButtonElements);

    const mapFilePath = this.settings.mapImagePath;
    mapDOM.querySelector("#map-image").src = mapFilePath;

    if (this.isPopup) {
      // If this is a popup, it does not need a size slider.
      navContainer.querySelector("#map-resizing-slider").remove();
      navContainer.querySelector("label").remove();
      // This is a query all instead of query in case multiple visibility buttons are added by the user.
      Array.from(
        navContainer.querySelectorAll("button[onclick='toggleMapVisibility()'")
      ).forEach((elem) => {
        elem.remove();
      });
    }
  }

  /**
   * If this is not a popup, identify label span pairs, identify table headers, and add appropriate
   * id's and classes to elements within both the Item Replacements and Item Locations tables. For
   * more information on what is actually done or what these set values look like, please see the
   * SharedModifier class definition.
   */
  preWrite() {
    // The map container exists in a page without the tracker. It does not need to make changes to a
    // non-existent tracker.
    if (this.isPopup) return;

    const sharedModifier = this.getAddOn("sharedModifier");
    sharedModifier.oneOffExecute("identifyLabeledSpans");
    sharedModifier.oneOffExecute("identifyHeaders");
    sharedModifier.oneOffExecute("prepItemReplacementsTable");
    sharedModifier.oneOffExecute("prepItemLocationsTable");
  }

  /**
   * Creates some JavaScript that groups together and adds a class to checkmark controls that should
   * be owned by specific regions in the map. This currently does not work for popup mode.
   * @returns {string} Valid JavaScript code to be injected into the tracker.
   */
  generateCheckJS() {
    // The generated JavaScript concatenates all target checkboxes for each region in arrays, adds a
    // class tying them to the parent region, and then runs hideIfAllChecked().
    var checkAssignmentJS =
      'window.addEventListener("afterTrackerStart", event => {';
    const regionData = this.settings.regionOwnership;
    const regionNames = Object.getOwnPropertyNames(regionData);

    regionNames.forEach((regionName) => {
      const ownedAreas = regionData[regionName].locations;
      if (ownedAreas.length == 1) {
        checkAssignmentJS +=
          "        Array.from(document.querySelectorAll('." +
          SharedModifier.generateCheckboxClass(ownedAreas[0]) +
          "'))";
      } else {
        ownedAreas.forEach((oa) => {
          checkAssignmentJS +=
            "        Array.from(document.querySelectorAll('." +
            SharedModifier.generateCheckboxClass(oa) +
            "'))";
          if (oa === ownedAreas[0]) {
            checkAssignmentJS += ".concat(\n    ";
          } else if (oa != ownedAreas[ownedAreas.length - 1]) {
            checkAssignmentJS += ",\n    ";
          }
        });
        checkAssignmentJS = checkAssignmentJS + ")";
      }
      // TODO: adjust this to account for popup mode
      // change value fed to hideIfAllChecked to region class in if else
      if (
        this.settings.enablePopupMode != null &&
        this.settings.enablePopupMode.toLowerCase() === "true"
      ) {
        checkAssignmentJS +=
          ".forEach(che => { che.classList.add('" +
          SharedModifier.generateRegionClass(regionName) +
          "'); });\n        hideIfAllChecked('." +
          SharedModifier.generateRegionClass(regionName) +
          "');\n";
      } else {
        checkAssignmentJS +=
          ".forEach(che => { che.classList.add('" +
          SharedModifier.generateRegionClass(regionName) +
          "'); });\n        hideIfAllChecked(document.querySelector('#" +
          SharedModifier.generateButtonId(regionName) +
          "'));\n";
      }
    });
    checkAssignmentJS += "});";
    return checkAssignmentJS;
  }

  /**
   * @property {string} mapImagePath - The URI path holds the map image.
   * @property {boolean} enableShortcuts - Enables shortcuts.
   * @property {boolean} enablePopupMode - Enables popup mode.
   * @property {boolean} hideClearedLocations - Hides region buttons when all associated checks are clicked.
   * @property {boolean} revertStyleInActorizer - Removes the larger styling of buttons that the actorizer adds.
   * @property {Array<Object>} navButtons - Information on the navigation buttons that appear atop the map container.
   * The property of each member object is attributed directly to the navigation button.
   * @property {Object} regionOwnership - Information on what region buttons are added to the map. Properties of
   * regionOwnership are the parents and members of locations are owned by the parent regions. Setting the locations
   * is recommended even if you don't plan on using settings.hideClearedLocations.
   */
  settings = {
    mapImagePath: "./img/MMR_Map.jpg",
    enableShortcuts: false,
    enablePopupMode: false,
    hideClearedLocations: true,
    revertStyleInActorizer: false,
    navButtons: [
      {
        id: "map-visibility-button",
        className: "navigation-button",
        onclick: "toggleMapVisibility()",
        innerHTML: "Hide Map",
      },
      {
        id: "go-to-top-button",
        classList: "navigation-button navigation-hideable",
        onclick: "goToId('#seed-span')",
        innerHTML: "Go To Top",
      },
      {
        id: "go-to-keys-button",
        classList: "navigation-button navigation-hideable",
        onclick: "goToId('#dungeonkeys-row')",
        innerHTML: "Dungeon Keys",
      },
      {
        id: "go-to-trades-button",
        classList: "navigation-button navigation-hideable",
        onclick: "goToId('#tradeitems-row')",
        innerHTML: "Trade Items",
      },
      {
        id: "go-to-locations-button",
        classList: "navigation-button navigation-hideable",
        onclick: "goToId('#item-locations')",
        innerHTML: "Item Locations",
      },
    ],
    regionOwnership: {
      "South Clock Town": {
        locations: [
          "South Clock Town",
          "North Clock Town",
          "East Clock Town",
          "Stock Pot Inn",
          "West Clock Town",
          "Laundry Pool",
        ],
        style:
          "top: 50%; right: 41.4%; background-color: #63c; border: 2px solid #f1e; color: #f1e",
        label: "CT",
        title: "Clock Town",
      },
      "Termina Field": {
        locations: ["Termina Field"],
        style:
          "top: 54.3%; right: 35.7%; background-color: #63c; border: 2px solid #f1e; color: #f1e",
        label: "Termina",
        title: "Termina Field",
      },
      "Road to Southern Swamp": {
        locations: ["Road to Southern Swamp", "Southern Swamp", "Deku Palace"],
        style:
          "top: 65%; right: 31%; background-color: green; border: 2px solid #2f2; color: #2f2",
        label: "SS",
        title: "Southern Swamp",
      },
      Woodfall: {
        locations: ["Woodfall", "Woodfall Temple"],
        style:
          "top: 74%; right: 22%; background-color: green; border: 2px solid #2f2; color: #2f2",
        label: "WF",
        title: "Woodfall",
      },
      "Mountain Village": {
        locations: ["Mountain Village", "Twin Islands"],
        style:
          "top: 35%; right: 58%; background-color: aliceblue; border: 2px solid #66f; color: #66f",
        label: "MV",
        title: "Mountain Village",
      },
      "Goron Village": {
        locations: ["Goron Village"],
        style:
          "top: 27.1%; right: 50%; background-color: aliceblue; border: 2px solid #66f; color: #66f",
        label: "GV",
        title: "Goron Village",
      },
      "Path to Snowhead": {
        locations: ["Path to Snowhead", "Snowhead Temple", "Snowhead"],
        style:
          "top: 12.9%; right: 81.4%; background-color: aliceblue; border: 2px solid #66f; color: #66f",
        label: "ST",
        title: "Snowhead",
      },
      "Milk Road": {
        locations: ["Milk Road", "Romani Ranch"],
        style:
          "top: 64%; right: 40%; background-color: green; border: 2px solid #2f2; color: #2f2",
        label: "MR",
        title: "Milk Road",
      },
      "Great Bay Coast": {
        locations: ["Great Bay Coast"],
        style:
          "top: 58%; right: 69%; background-color: aqua; border: 2px solid #22f; color: #22f",
        label: "GB",
        title: "Great Bay Coast",
      },
      "Zora Cape": {
        locations: ["Zora Cape", "Zora Hall"],
        style:
          "top: 69%; right: 69%; background-color: aqua; border: 2px solid #22f; color: #22f",
        label: "ZC",
        title: "Zora Cape",
      },
      "Pirates Fortress Exterior": {
        locations: [
          "Pirates Fortress Exterior",
          "Pirates Fortress Sewer",
          "Pirates Fortress Interior",
        ],
        style:
          "top: 43%; right: 68%; background-color: aqua; border: 2px solid #22f; color: #22f",
        label: "PF",
        title: "Pirates Fortress",
      },
      "Pinnacle Rock": {
        locations: ["Pinnacle Rock"],
        style:
          "top: 52%; right: 86.5%; background-color: aqua; border: 2px solid #22f; color: #22f",
        label: "PR",
        title: "Pinnacle Rock",
      },
      "Great Bay Temple": {
        locations: ["Great Bay Temple"],
        style:
          "top: 60%; right: 84%; background-color: aqua; border: 2px solid #22f; color: #22f",
        label: "GBT",
        title: "Great Bay Temple",
      },
      "Road to Ikana": {
        locations: ["Road to Ikana", "Ikana Graveyard"],
        style:
          "top: 40%; right: 28%; background-color: burlywood; border: 2px solid #a2a; color: #a2a",
        label: "RI",
        title: "Road to Ikana",
      },
      "Ikana Canyon": {
        locations: ["Ikana Canyon", "Beneath the Well", "Ikana Castle"],
        style:
          "top: 31.4%; right: 17.1%; background-color: burlywood; border: 2px solid #a2a; color: #a2a",
        label: "IC",
        title: "Ikana Canyon",
      },
      "Stone Tower": {
        locations: ["Stone Tower Temple", "Stone Tower"],
        style:
          "top: 24.3%; right: 8.6%; background-color: burlywood; border: 2px solid #a2a; color: #a2a",
        label: "STT",
        title: "Stone Tower",
      },
      "Secret Shrine": {
        locations: ["Secret Shrine"],
        style:
          "top: 30%; right: 22.9%; background-color: burlywood; border: 2px solid #a2a; color: #a2a",
        label: "SS",
        title: "Secret Shrine",
      },
      "The Moon": {
        locations: ["The Moon"],
        style:
          "top: 88%; right: 2.3%; background-color: #63c; border: 2px solid #f1e; color: #f1e",
        label: "The Moon",
        title: "The Moon",
      },
    },
  };
}

/** Sets theme and and automatically highlights checks on start. */
class AutoDarkHighlight extends AddOn {
  key = "autoDarkHighlight";
  name = "Auto Dark Mode + Highlight";
  description = "Sets dark mode and item highlights automatically.";
  promisedSnippets = ["script"];
  /**
   * @property {string} defaultTheme - The theme the tracker starts with. light/dark.
   * @property {boolean} highlightChecks - Highlights checks on start.
   */
  settings = {
    defaultTheme: "dark",
    highlightChecks: true,
  };

  /**
   * Creates the script snippet that provides this add-on's functionality.
   */
  bake() {
    this.newSnippet(
      "script",
      document.getElementById("autoDarkHighlight-script"),
      "text/html"
    );
  }
}

/**
 * Provides shared resources to manipulating the original tracker, and communication
 * infrastructure for popups. Does nothing on its own.
 */
class SharedModifier extends AddOn {
  key = "sharedModifier";
  name = "Shared Modifier";
  description = "[REQUIRED] A tool shared by multiple add-on's.";
  promisedSnippets = [];
  /**
   * Methods that have already been run via SharedModifier.oneOffExecute().
   * @type {Array<string>}
   */
  executedFunctions = [];
  /**
   * The DOM generated for the "tracker/content" Snippet instance.
   * @type {Object}
   */
  originalDOM;

  /**
   * If any sharedModifier snippet has been included by another add-on (like "sharedModifier/communication"),
   * this creates those snippets.
   */
  bake() {
    this.promisedSnippets.forEach((snippetName) => {
      this.newSnippet(
        snippetName,
        document.getElementById("sharedModifier-" + snippetName),
        "text/html"
      );
    });
  }

  /**
   * Adds a snippet to the SharedModifier instance's promisedSnippets, prompting it to later create
   * said snippet. If a snippet of the given name has already been included, do nothing.
   * @param {string} snippetName - The snippet name that points to some sharedModifier script with the
   * id "sharedModifier-[snippetName]".
   */
  include(snippetName) {
    if (!this.promisedSnippets.includes(snippetName))
      this.promisedSnippets.push(snippetName);
  }

  /**
   * Runs a method, whose name is provided, of the SharedModifier instance, but only once. If the
   * same method is accessed to run again, it does nothing. This is to prevent harmful changes to
   * the tracker from multiple add-on's needing the same change. Due to the oneOffExecute options all
   * being tied to the original tracker, this will throw an error to prevent unexpected behavior and
   * errors.
   * @param {string} functionName - The method within SharedModifier that is run.
   */
  oneOffExecute(functionName) {
    // If this is the first oneOffExecute call, get the tracker DOM.
    if (this.originalDOM == null) {
      this.originalDOM = this.getExternalSnippet("tracker/content").DOM;
      // Double check that a valid DOM was found. Throw an error otherwise.
      if (this.originalDOM == null) {
        throw new Error(
          "SharedModifier.oneOffExecute() was run before 'tracker/content' was created."
        );
      }
    }

    if (!this.executedFunctions.includes(functionName)) {
      // Run the desired method, and then add it to an array to keep it from running again.
      this[functionName]();
      this.executedFunctions.push(functionName);
    }
  }

  /**
   * Adds an id of "settings-tag" to the settings code block at the top of the page. If the code element already has
   * an id, some code in the Actorizer needs to be changed to reference this new id.
   */
  identifyCodeBlock() {
    // Checks to see if you are playing with the actorizer.
    if (this.originalDOM.querySelector("code").id) {
      const targetScript = this.originalDOM.querySelector("script");
      const originalContent = targetScript.innerText;
      // target and replace showHideSettings() to reference the "settings-tag" id.
      targetScript.innerText = "";
      targetScript.appendChild(
        document.createTextNode(
          originalContent.slice(
            0,
            originalContent.search("function showHideSettings()")
          ) +
            `
function showHideSettings() {
    var settingsCode = document.getElementById("settings-tag");
    settingsCode.classList.toggle("invisible");
}` +
            originalContent.slice(
              originalContent.indexOf(
                "}",
                originalContent.search("function showHideSettings()")
              ) + 1
            )
        )
      );
    }
    this.originalDOM.querySelector("code").id = "settings-tag";
  }

  /**
   * Adds an id of "[label contents]-span" to the version and seed spans.
   */
  identifyLabeledSpans() {
    // The slice is to ignore any following spans that have been added by forks of the randomizer.
    Array.from(this.originalDOM.querySelectorAll("label + span"))
      .slice(0, 2)
      .forEach((span) => {
        var idSourceString = span.previousSibling.querySelector("b").innerHTML;
        idSourceString = idSourceString.split(":")[0].toLowerCase().trim();
        span.id = idSourceString + "-span";
      });
  }

  /**
   * Adds an id of "[heading-text-in-lowercase]-heading" to all h2 elements.
   */
  identifyHeaders() {
    Array.from(this.originalDOM.querySelectorAll("h2")).forEach((header) => {
      header.id = SharedModifier.cleanUpString(header.innerHTML) + "-heading";
    });
  }

  /**
   * Adds an id of "[preceding-h2-text-in-lowercase]" to each table.
   */
  identifyTables() {
    const headerElemArray = Array.from(this.originalDOM.querySelectorAll("h2"));
    Array.from(this.originalDOM.querySelectorAll("table")).forEach((table) => {
      table.id = SharedModifier.cleanUpString(
        headerElemArray.shift().innerHTML
      );
    });
  }

  /**
   * Adds a tab index of 0 to rows in Dungeon Entrance Replacements and Item Replacements,
   * allowing the user to tab through them.
   */
  makeChecksFocusable() {
    const locationList = Array.from(
      this.originalDOM.querySelectorAll(".newlocation:not(:has(span))")
    );
    locationList.forEach((elem) => {
      elem.setAttribute("tabindex", 0);
    });
  }

  /**
   * Adds region information for each checkbox, identifies region rows, and makes it easier
   * for the MarkedLogGenerator add-on to find pertinent replacement checks. Also runs
   * SharedModifier.identifyTables().
   */
  prepItemReplacementsTable() {
    this.oneOffExecute("identifyTables");
    const itemReplacementsTable =
      this.originalDOM.querySelector("#item-replacements");
    itemReplacementsTable
      .querySelectorAll("input")
      .forEach((inputElem) => inputElem.classList.add("location-check"));
    var currentRegion;
    itemReplacementsTable.querySelectorAll("tr").forEach((tr) => {
      switch (tr.className) {
        case "region":
          const td = tr.firstChild;
          td.id = SharedModifier.cleanUpString(td.innerHTML) + "-row";
          currentRegion = SharedModifier.cleanUpString(td.innerHTML) + "-check";
          break;
        case "available":
        case "unavailable":
          tr.querySelector("input").classList.add(currentRegion);
        default:
        // do nothing. it's the first row
      }
    });
  }

  /**
   * Identifies rows in the Item Locations table for navigation purposes, and enables
   * the ShowCollected add-on to check all associated checkboxes at once by adding the
   * class "secondary-location-check".
   */
  prepItemLocationsTable() {
    this.oneOffExecute("identifyTables");
    const itemsLocationTable =
      this.originalDOM.querySelector("#item-locations");
    itemsLocationTable.querySelectorAll('tr[class="region"]').forEach((tr) => {
      const td = tr.firstChild;
      td.id = SharedModifier.cleanUpString(td.innerHTML) + "-row";
    });
    itemsLocationTable
      .querySelectorAll("input")
      .forEach((inputElem) =>
        inputElem.classList.add("secondary-location-check")
      );
  }

  /**
   * Adds class information to gossip entires for the MarkedLogGenerator.
   */
  prepGossipStoneHintsTable() {
    this.oneOffExecute("identifyTables");
    const gossipStoneHintsTable = this.originalDOM.querySelector(
      "#gossip-stone-hints"
    );
    if (!gossipStoneHintsTable) return;
    gossipStoneHintsTable.querySelectorAll("tr").forEach((tr) => {
      const spoilerSpan = tr.querySelector("span");
      if (spoilerSpan) {
        tr.querySelector("td:not(.spoiler)").classList.add("gossip-location");
        spoilerSpan.classList.add("gossip-hint");
      }
    });
  }

  static cleanUpString(regionName) {
    return regionName.replace(/\s/g, "-").replace("'", "").toLowerCase();
  }
  static generateRegionClass(regionName) {
    return SharedModifier.cleanUpString(regionName) + "-region-check";
  }
  static generateCheckboxClass(regionName) {
    return SharedModifier.cleanUpString(regionName) + "-check";
  }
  static generateButtonId(regionName) {
    return SharedModifier.cleanUpString(regionName) + "-region-button";
  }
  static generateRowId(regionName) {
    return SharedModifier.cleanUpString(regionName) + "-row";
  }
}

/** Provides persistent, automatic storage of tracker state. */
class StateSaver extends AddOn {
  key = "stateSaver";
  name = "Tracker State Saver";
  description =
    "[LOCALSTORAGE] Automatically saves tracker progress such that it persists between play sessions.";
  promisedSnippets = ["style", "globals", "script"];

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "style",
      document.getElementById("stateSaver-style"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("stateSaver-globals"),
      "text/html"
    );
    this.newSnippet(
      "script",
      document.getElementById("stateSaver-script"),
      "text/html"
    );
  }

  /**
   * Hides the tracker body, identifies labeled spans, and identifies/classifies multiple elements
   * within both the Item Replacements and Item Locations tables. For more information on what is
   * done to these elements, please see the SharedModifier class definition.
   */
  preWrite() {
    this.getExternalSnippet("tracker/content").DOM.body.style.display = "none";
    this.getAddOn("sharedModifier").oneOffExecute("identifyLabeledSpans");
    this.getAddOn("sharedModifier").oneOffExecute("prepItemReplacementsTable");
    this.getAddOn("sharedModifier").oneOffExecute("prepItemLocationsTable");
  }
}

/** Exports a version of the spoiler log with collected checks marked. */
class MarkedLogGenerator extends AddOn {
  key = "markedLogGenerator";
  name = "Marked Log Generator";
  description =
    "Allows for exporting a spoiler log with collected items marked off.";
  promisedSnippets = ["content", "globals"];

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "content",
      document.getElementById("markedLogGenerator-content"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("markedLogGenerator-globals"),
      "text/html"
    );
  }

  /**
   * Identifies the settings code block, labeled spans, and various elements in tables.
   */
  preWrite() {
    const originalDOM = this.getExternalSnippet("tracker/content").DOM;
    const sharedModifier = this.getAddOn("sharedModifier");
    // make modifications to make querying easier later
    sharedModifier.oneOffExecute("identifyCodeBlock");
    sharedModifier.oneOffExecute("identifyLabeledSpans");
    sharedModifier.oneOffExecute("identifyTables");
    // Modify dungeon entrance, item replacements, and gossip stone tables.
    const entranceTable = originalDOM.querySelector(
      "#dungeon-entrance-replacements"
    );
    // This change is only useful for MarkedLogGenerator, so it's done here
    // instead of in SharedModifier.
    if (entranceTable) {
      // The entrance table exists.
      entranceTable
        .querySelectorAll("input")
        .forEach((inputElem) => inputElem.classList.add("entrance-check"));
      entranceTable
        .querySelectorAll("span")
        .forEach((span) => span.classList.add("spoiler-span"));
    }
    sharedModifier.oneOffExecute("prepItemReplacementsTable");
    originalDOM
      .querySelectorAll("#item-replacements span")
      .forEach((span) => span.classList.add("spoiler-span"));
    sharedModifier.oneOffExecute("prepGossipStoneHintsTable");
  }
}

/** Re-enables a latent feature of the original tracker that highlights collected checks differently. */
class ShowCollected extends AddOn {
  key = "showCollected";
  name = "Show Collected Checks";
  description = "Re-enables collected check highlighting.";
  promisedSnippets = ["style", "globals", "script", "shortcuts"];
  /**
   * @property {boolean} enableShortcuts - Enables shortcuts.
   * @property {boolean} enableOnStart - Checks the recolor box automatically.
   * @property {string} lightModeFormat - Styling for highlighted light-mode checks.
   * @property {string} darkModeFormat - Styling for highlighted dark-mode checks.
   */
  settings = {
    enableShortcuts: false,
    enableOnStart: true,
    lightModeFormat: "background-color: #99FF99",
    darkModeFormat: "background-color: #69591F",
  };

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "style",
      document.getElementById("showCollected-style"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("showCollected-globals"),
      "text/html"
    );
    this.newSnippet(
      "script",
      document.getElementById("showCollected-script"),
      "text/html"
    );
    this.newOptionalSnippet(
      "shortcuts",
      document.getElementById("showCollected-shortcuts"),
      "text/html",
      this.settings.enableShortcuts != null &&
        this.settings.enableShortcuts.toString().toLowerCase() === "true",
      "Having shortcuts enabled on ShowCollected adds the following:\n" +
        '[CTRL + SHIFT+ c] => toggle "Recolor collected checks" checkbox'
    );
  }

  /**
   * Injects a "recolor collected checks" checkbox into the tracker below the highlight checks option.
   * Makes some minor changes to the Item Replacements and Item Locations tables to facilitate
   * keeping the highlight consistent regardless of which table you are clicking checks in.
   */
  preWrite() {
    const showCollectedCheckbox = document.createElement("input");
    showCollectedCheckbox.id = "highlight-collected";
    showCollectedCheckbox.type = "checkbox";
    this.getAddOn("sharedModifier").oneOffExecute("prepItemReplacementsTable");
    this.getAddOn("sharedModifier").oneOffExecute("prepItemLocationsTable");
    const trackerContent = this.getExternalSnippet("tracker/content").DOM;
    const itemReplacementsTable =
      trackerContent.querySelector("#item-replacements");
    const labelText = document.createElement("p");
    labelText.appendChild(document.createTextNode("Recolor collected checks"));
    const span = document.createElement("span");
    span.style.display = "flex";
    span.appendChild(showCollectedCheckbox);
    span.appendChild(labelText);

    // Injects the new option just before the Item Replacements table.
    trackerContent.body.insertBefore(span, itemReplacementsTable);
  }
}

/** Facilitates spoiler-less text search in the Item Replacements table. */
class TextSearch extends AddOn {
  key = "textSearch";
  name = "Text Search";
  description =
    "Jumps to and highlights first check name match based on recent typing";
  promisedSnippets = ["style", "field", "globals", "script"];
  /**
   * @property {string} idleClearTimeMs - How long to wait, in milliseconds, before clearing the search box.
   */
  settings = {
    idleClearTimeMs: "1000",
  };

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "style",
      document.getElementById("textSearch-style"),
      "text/html"
    );
    this.newSnippet(
      "field",
      document.getElementById("textSearch-field"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("textSearch-globals"),
      "text/html"
    );
    this.newSnippet(
      "script",
      document.getElementById("textSearch-script"),
      "text/html"
    );
  }

  /**
   * Adds a tab index of 0 to Item Replacements table entries.
   */
  preWrite() {
    this.getAddOn("sharedModifier").oneOffExecute("makeChecksFocusable");
  }
}

/** NOT IMPLEMENTED */
class AutoTracker extends AddOn {
  key = "autoTracker";
  name = "Auto Tracker";
  description = "Enables automatic tracker updates with Project64";
  promisedSnippets = [];
  bake() {
    alert("AutoTracker is not yet implemented.");
  }
}

/** TO BE REMOVED */
class TimeKeeper extends AddOn {
  key = "timeKeeper";
  name = "Time Keeper";
  description = "[LOCALSTORAGE] Tracks time played between multiple sessions";
  promisedSnippets = [];
  preBake() {
    this.getAddOn("sharedModifier").include("communicator");
  }
  bake() {
    if (this.isPopup) {
      this.promisedSnippets = ["content", "globals", "activator"];
      this.newSnippet(
        "content",
        document.getElementById("timeKeeper-content"),
        "text/html"
      );
      this.newSnippet(
        "globals",
        document.getElementById("timeKeeper-popup-globals"),
        "text/html"
      );
      this.newSnippet(
        "activator",
        document.getElementById("timeKeeper-popup-activator"),
        "text/html"
      );
    } else {
      this.promisedSnippets = ["communicator"];
      this.newSnippet(
        "communicator",
        document.getElementById("timeKeeper-communicator"),
        "text/html"
      );
    }
  }
}

/** NOT READY */
class ItemTracker extends AddOn {
  key = "itemTracker";
  name = "Item Tracker";
  description = "Provides a visual item tracker.";
  promisedSnippets = [];
  bake() {
    alert("ItemTracker is not yet implemented.");
  }
  settings = {
    mode: "responsive", // read-only, write-only, responsive, adaptive
    promptType: "list", // textbox, list
    anchorPoint: "top-right", // top-left, top, top-right, left, right, bottom-left, bottom, bottom-right, in-tab
    trust: 0.95, // 0.0-1.0, percent chance to give a prompt despite only one available check
  };
}

/** Notes panel to track gossip hints. */
class Annotator extends AddOn {
  key = "annotator";
  name = "Annotator";
  description = "Take notes, pin locations or items, mark junk.";
  promisedSnippets = [
    "style",
    "content",
    "autocomplete",
    "globals",
    "script",
    "shortcuts",
  ];
  /**
   * @property {string} panelColor - Color of the notes panel.
   * @property {string} collapseButtonStyle - Style string for the collapse button.
   * @property {string} textboxStyle - Style string for the notes textbox.
   * @property {boolean} enableShortcuts - Enables shortcuts.
   */
  settings = {
    panelColor: "rgb(44, 102, 49)",
    collapseButtonStyle: "background-color: purple; color: white",
    textboxStyle:
      "background-color: rgb(128,0,128); border: 1px solid rgb(78,0,78); color: white",
    enableShortcuts: false,
  };

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "style",
      document.getElementById("annotator-style"),
      "text/html"
    );
    this.newSnippet(
      "content",
      document.getElementById("annotator-content"),
      "text/html"
    );
    this.newSnippet(
      "autocomplete",
      document.getElementById("annotator-autocomplete"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("annotator-globals"),
      "text/html"
    );
    this.newSnippet(
      "script",
      document.getElementById("annotator-script"),
      "text/html"
    );
    this.newOptionalSnippet(
      "shortcuts",
      document.getElementById("annotator-shortcuts"),
      "text/html",
      this.settings.enableShortcuts != null &&
        this.settings.enableShortcuts.toString().toLowerCase() === "true",
      "Having shortcuts enabled on Annotator adds the following:\n" +
        "[SHIFT + N]\t=> Toggle notes panel visibility"
    );
  }

  /**
   * Identifies tables, and adds a tab index of 0 to Item Replacements row entries.
   */
  preWrite() {
    this.getAddOn("sharedModifier").oneOffExecute("identifyTables");
    this.getAddOn("sharedModifier").oneOffExecute("makeChecksFocusable");
  }
}

/** Implements the Actorizer's filtering system. */
class CheckFilterer extends AddOn {
  key = "checkFilterer";
  name = "Check Filterer";
  description =
    "A filterer for collected checks. Replaces Isghj's Actorizer filtering system with something that eliminates the need for a refresh button.";
  promisedSnippets = ["style", "globals", "script"];

  /**
   * Creates necessary snippets.
   */
  bake() {
    this.newSnippet(
      "style",
      document.getElementById("checkFilterer-style"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("checkFilterer-globals"),
      "text/html"
    );
    this.newSnippet(
      "script",
      document.getElementById("checkFilterer-script"),
      "text/html"
    );
  }

  /**
   * Identifies headers, tables, and modifies the tracker to work with this add-on.
   * This will either remove the updateItemDisplaySettings() function from an
   * Actorizer tracker, or inject filtering elements into a non-Actorizer tracker.
   */
  preWrite() {
    this.getAddOn("sharedModifier").oneOffExecute("identifyHeaders");
    const trackerDOM = this.getExternalSnippet("tracker/content").DOM;
    // If this is an Actorizer tracker
    if (trackerDOM.querySelector(".settingsFlex")) {
      // Modify the existing filtering checkboxes to work with this add-on.
      Array.from(trackerDOM.querySelectorAll(".settingsFlex input")).forEach(
        (elem) => {
          elem.setAttribute("data-target", elem.id);
          elem.removeAttribute("onclick");
          elem.removeAttribute("id");
        }
      );
      // Remove the updateItemDisplaySettings() method, as this add-on has its own implementation.
      // This leaves the removableSettings lines that precede it intact.
      const targetScript = trackerDOM.querySelector("script");
      const originalContent = targetScript.innerText;
      targetScript.innerText = "";
      targetScript.appendChild(
        document.createTextNode(
          originalContent.slice(
            0,
            originalContent.search("function updateItemDisplaySettings()")
          )
        )
      );
      // Remove the "Refresh" button.
      trackerDOM.querySelector(".centeredLabel").remove();
    } else {
      // Create and inject the filtering checkboxes.
      // This should match the structure of the Actorizer for the sake of consistency.
      const previousElement = trackerDOM.getElementById(
        "item-replacements-heading"
      );
      const hideItemLabel = document.createElement("label");
      hideItemLabel.id = "hideItemLabel";
      const hideItemContent = document.createElement("b");
      hideItemContent.appendChild(document.createTextNode("Hide Item Types:"));
      hideItemLabel.appendChild(hideItemContent);
      const hideItemCheckList = document.createElement("span");
      hideItemCheckList.className = "settingsFlex";
      const hideableCategories = [
        "permanents",
        "lowRupees",
        "highRupees",
        "hearts",
        "bottleContents",
        "ammo",
      ];
      const hideableNames = [
        "Premanents/Traps",
        "Low Value Rupees",
        "High Value Rupees",
        "Hearts",
        "Bottle Contents",
        "Ammo",
      ];
      hideableCategories.forEach((category, i) => {
        const entrySpan = document.createElement("span");
        const entryInput = document.createElement("input");
        entryInput.type = "checkbox";
        entryInput.setAttribute("data-target", category);
        entryInput.onclick = "updateItemDisplaySettings(event)"; // I don't think this line works.
        entrySpan.appendChild(entryInput);
        entrySpan.appendChild(document.createTextNode(hideableNames[i]));
        hideItemCheckList.appendChild(entrySpan);
      });
      previousElement.after(hideItemLabel, hideItemCheckList);

      // Append the removableSettings lines.
      // TODO: Maybe just include this in a separate script.
      const targetScript = trackerDOM.querySelector("script");
      const originalContent = targetScript.innerText;
      targetScript.innerText = "";
      targetScript.appendChild(
        document.createTextNode(
          originalContent +
            `
/* ^^^^    From Isghj's Actorizer Test 88.3    ^^^^ */
removableSettings = {};
removableSettings["hearts"] = ["Piece of Heart", "Heart Container", "Recovery Heart"];
removableSettings["lowRupees"] = ["Blue Rupee", "Red Rupee"];
removableSettings["highRupees"] = ["Purple Rupee", "Silver Rupee", "Gold Rupee"];
removableSettings["bottleContents"] = ["Bottle:", "Milk", "Chateau", "Potion"];
removableSettings["permanents"] = ["Mask", "Stray Fairy", "Skulltula Spirit", "Song", "Sonata", "Lullaby", "Bossa", "Elegy", "Oath to Order", "Shield", "Upgrade", "Pictobox", "Lens of Truth", "Hookshot", "Spin Attack", "Double Defense", "Sword", "Notebook", "Hat", "Hood", "Map", "Ice Trap", "Empty Bottle", "Compass"];
removableSettings["ammo"] = ["Arrow", "Bombs", "Bombchu", "Deku Nuts", "Deku Stick"];
/* ^^^^    From Isghj's Actorizer Test 88.3    ^^^^ */`
        )
      );
    }
    this.getAddOn("sharedModifier").oneOffExecute("identifyTables");
  }
}

/** Handles shortcut creation, rebinding, and persistence. */
class ShortcutManager extends AddOn {
  key = "shortcutManager";
  name = "Shortcut Manager";
  description =
    "[REQUIRED] Facilitates shortcut activations. Prevents multiple shortcuts from having the same key.";
  promisedSnippets = ["dialogs", "globals", "activator"];

  /**
   * Create the necessary snippets.
   */
  bake() {
    this.newSnippet(
      "dialogs",
      document.getElementById("shortcutManager-dialogs"),
      "text/html"
    );
    this.newSnippet(
      "globals",
      document.getElementById("shortcutManager-globals"),
      "text/html"
    );
    this.newSnippet(
      "activator",
      document.getElementById("shortcutManager-activator"),
      "text/html"
    );

    if (AddOn.showsAlerts) {
      alert(
        "Shortcut Manager bindings.\n" +
          "[CTRL + B] => Show shortcut binding manager.\n" +
          "[CTRL + SHIFT + B] => Revert to default bindings."
      );
    }
  }
}
